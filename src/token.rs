use common_macros::hash_set;
use lazy_static::lazy_static;
use std::collections::HashSet;
use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Identifier(String),
    ReservedWord(String),
    Float(String),
    Integer(String),
    LitString(String),
    Dot,
    Coma,
    Colon,
    ColonPath,
    SemiColon,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,
    LeftParenthesis,
    RightParenthesis,
    Equal,
    NotEqual,
    LessThan,
    LessEqual,
    GreaterThan,
    GreaterEqual,
    Assign,
    Atsym,
    Dollar,
    Tilde,
    TildeAssign,
    Asterisk,
    AsteriskAssign,
    Plus,
    PlusAssign,
    Minus,
    MinusAssign,
    Divide,
    DivideAssign,
    Percetange,
    PercetangeAssign,
    Ampersand,
    AmpersandAssign,
    VerticalBar,
    VerticalBarAssign,
    DoubleAmpersand,
    DoubleAmpersandAssign,
    DoubleVerticalBar,
    DoubleVerticalBarAssign,
    SingleQuote,
    QuestionMark,
    ExclamationMark,
    Underscore,
    DoubleDots,
    TripleDots,
    SingleArrow,
    DoubleArrow,
    Tab,
    Space,
    Newline,
    BlockComment(String),
    InlineComment(String),
    EndOfFile,
}

impl Token {
    pub fn is_whitespace(&self) -> bool {
        match self {
            Token::Tab | Token::Space | Token::Newline => true,
            _ => false,
        }
    }
}

impl fmt::Display for Token {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let out = match self {
            Token::Identifier(id) => id.to_owned(),
            Token::ReservedWord(word) => word.to_string(),
            Token::Float(_) => "{float}".to_owned(),
            Token::Integer(_) => "{integer}".to_owned(),
            Token::LitString(_) => "{string}".to_owned(),
            Token::Dot => ".".to_owned(),
            Token::Coma => ",".to_owned(),
            Token::Colon => ":".to_owned(),
            Token::ColonPath => "::".to_owned(),
            Token::SemiColon => ";".to_owned(),
            Token::LeftBrace => "{".to_owned(),
            Token::RightBrace => "}".to_owned(),
            Token::LeftBracket => "[".to_owned(),
            Token::RightBracket => "]".to_owned(),
            Token::LeftParenthesis => "(".to_owned(),
            Token::RightParenthesis => ")".to_owned(),
            Token::Equal => "==".to_owned(),
            Token::NotEqual => "!=".to_owned(),
            Token::LessThan => "<".to_owned(),
            Token::LessEqual => "<=".to_owned(),
            Token::GreaterThan => ">".to_owned(),
            Token::GreaterEqual => ">=".to_owned(),
            Token::Assign => "=".to_owned(),
            Token::Atsym => "@".to_owned(),
            Token::Dollar => "$".to_owned(),
            Token::Tilde => "~".to_owned(),
            Token::TildeAssign => "~=".to_owned(),
            Token::Asterisk => "*".to_owned(),
            Token::AsteriskAssign => "*=".to_owned(),
            Token::Plus => "+".to_owned(),
            Token::PlusAssign => "+=".to_owned(),
            Token::Minus => "-".to_owned(),
            Token::MinusAssign => "-=".to_owned(),
            Token::Divide => "/".to_owned(),
            Token::DivideAssign => "/=".to_owned(),
            Token::Percetange => "%".to_owned(),
            Token::PercetangeAssign => "%=".to_owned(),
            Token::Ampersand => "&".to_owned(),
            Token::AmpersandAssign => "&=".to_owned(),
            Token::VerticalBar => "|".to_owned(),
            Token::VerticalBarAssign => "|=".to_owned(),
            Token::DoubleAmpersand => "&&".to_owned(),
            Token::DoubleAmpersandAssign => "&&=".to_owned(),
            Token::DoubleVerticalBar => "||".to_owned(),
            Token::DoubleVerticalBarAssign => "||=".to_owned(),
            Token::SingleQuote => "'".to_owned(),
            Token::QuestionMark => "?".to_owned(),
            Token::ExclamationMark => "!".to_owned(),
            Token::Underscore => "_".to_owned(),
            Token::DoubleDots => "..".to_owned(),
            Token::TripleDots => "...".to_owned(),
            Token::SingleArrow => "->".to_owned(),
            Token::DoubleArrow => "=>".to_owned(),
            Token::Tab => "\\t".to_owned(),
            Token::Space => " ".to_owned(),
            Token::Newline => "\\n".to_owned(),
            Token::BlockComment(_) => "{block_comment}".to_owned(),
            Token::InlineComment(_) => "{inline_comment}".to_owned(),
            Token::EndOfFile => "EOF".to_owned(),
        };

        write!(f, "{}", out)
    }
}

lazy_static! {
    static ref RESERVED_WORDS: HashSet<&'static str> = hash_set! {
        "while",
        "if",
        "for",
        "else",
        "elif",
        "struct",
        "do",
        "main",
        "trait",
        "async",
        "await",
        "sync",
        "let",
        "fn",
        "pub",
        "loop",
        "until",
        "impl",
        "static",
        "enum",
        "use",
        "as",
        "const",
        "mut",
        "where",
        "self",
        "Self",
        "is",
        "throw",
        "match",
        "with",
        "when",
        "meta",
        "macro",
        "mod",
        "ref",
        "return",
        "in",
        "continue",
        "break",
        "type",
        "dyn",
        "true",
        "false",
        "_",
    };
}

pub fn is_reserved_word(lexeme: &str) -> bool {
    RESERVED_WORDS.contains(lexeme)
}
